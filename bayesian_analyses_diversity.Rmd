---
title: "Bayesian analyses for diversity"
output: html_notebook
---

## Strategies for selection

There are 6 proposed strategies that children and adults may be utilizing in the diversity task.

1. **Random Strategy:** In this strategy, participants choose randomly across the 4 available options regardless of the choice made by the experimenter. The only thing they don't do is choose the option that was selected by the experimenter. 
2. **Extreme Strategy:** In this strategy, the participant chooses the most extreme value on the scale available to select from. Thus, the participant chooses 5 unless 5 was already selected. If the latter is the case, the participant chooses 4. Currently, this strategy does not account for valence is written in the code. This is the strategy we expect children to use. 
3. **Diverse Strategy:** In this strategy, participants are adjusting their choice relative to the experimenter choice. Participants maximize distance between their choice and the experimenter's choice. This is one of the strategies we expect adults might be using. 
4. **Average Strategy:**: In this strategy, participants are trying to choose an option that, when averaged with the experimenter's choice, comes out to equal 3; that is, they are trying to make the selection space reflect the average of the choices. We expect adults may be utilizing this strategy, too. 
5. **Middle Strategy:** In this strategy, participants choose the middle option regardless of the experimenter's choice. In the instance that the middle has already been selected, they choose an option nearest to the middle. 
6. **Researcher-adjacent Strategy:**: In this strategy, participants choose an option that is adjacent to the experimenter's choice, either the option above or below. 

Below, I computationally define each of the 6 strategies. `exp_choice` refers to the experimenter's choice. `agent_choice` refers to the participant's choice. I've chosen to refer to the participant as an `agent` in this code as it is standard practice in computational modeling to do so.

```{r}
random <- function(exp_choice){
  a <- c(1:5)
  a <- a[-exp_choice]
  agent_choice <- sample(a,1)
  return(agent_choice)
}

extreme <- function(exp_choice){
  if (exp_choice == 5) {
    agent_choice <- 4
  } else {
    agent_choice <- 5
  }
  return(agent_choice)
}

diverse <- function(exp_choice){
  if (exp_choice > 3){
    agent_choice <- 1
  } else if (exp_choice < 3){
    agent_choice <- 5
  } else {
    a <- c(1,5)
    agent_choice <- sample(a,1)
  }
  return(agent_choice)
}

average <- function(exp_choice){
  if (exp_choice == 3){
    a <- c(2,4)
    agent_choice <- sample(a,1)
  } else {
  agent_choice <- 6 - exp_choice
  }
  return(agent_choice)
}

middle <- function(exp_choice){
  if (exp_choice != 3){
    agent_choice <- 3
  } else {
    a <- c(2,4)
    agent_choice <- sample(a,1)
  }
  return(agent_choice)
}

adjacent <- function(exp_choice){
  if (exp_choice == 1) {
    agent_choice <- 2
  } else if (exp_choice == 5) {
    agent_choice <- 4 
  } else {
    a <- c(exp_choice+1,exp_choice-1)
    agent_choice <- sample(a,1)
  }
  return(agent_choice)
}

strategies <- c("random", "extreme", "diverse", "average", "middle", "adjacent")
```

## The agents 

Here, I define each of the six possible agents. Every agent with an explicit strategy still has an opportunity to behave randomly when selecting, and the rate at which the agent behaves randomly is defined by the value `epsilon`. 

Each of these agents returns what the experimenter chose, their own choice, and the strategy they implemented to reach their choice. 
```{r}
random_agent <- function(exp_choice){
  agent_choice <- random(exp_choice)
  strategy <- "random"
  # print(paste0("Agent used the ", strategy, " strategy and picked ", agent_choice))
  x <- c(strategy, exp_choice, agent_choice)
  return(x)
}

extreme_agent <- function(exp_choice){
  b <- runif(1, 0, 1)
  if (b > epsilon){
    agent_choice <- extreme(exp_choice)
    strategy <- "extreme"
  } else {
    agent_choice <- random(exp_choice)
    strategy <- "random"
  } 
  # print(paste0("Agent used the ", strategy, " strategy and picked ", agent_choice))
  x <- c(strategy, exp_choice, agent_choice)
  return(x)
}

diverse_agent <- function(exp_choice){
  b <- runif(1, 0, 1)
  if (b > epsilon){
    agent_choice <- diverse(exp_choice)
    strategy <- "diverse"
  } else {
    agent_choice <- random(exp_choice)
    strategy <- "random"
  }
  # print(paste0("Agent used the ", strategy, " strategy and picked ", agent_choice))
  x <- c(strategy, exp_choice, agent_choice)
  return(x)
}

average_agent <- function(exp_choice){
  b <- runif(1, 0, 1)
  if (b > epsilon){
    agent_choice <- average(exp_choice)
    strategy <- "average"
  } else {
    agent_choice <- random(exp_choice)
    strategy <- "random"
  }
  # print(paste0("Agent used the ", strategy, " strategy and picked ", agent_choice))
  x <- c(strategy, exp_choice, agent_choice)
  return(x)
}

middle_agent <- function(exp_choice){
  b <- runif(1, 0, 1)
  if (b > epsilon){
    agent_choice <- middle(exp_choice)
    strategy <- "middle"
  } else {
    agent_choice <- random(exp_choice)
    strategy <- "random"
  }  
  # print(paste0("Agent used the ", strategy, " strategy and picked ", agent_choice))
  x <- c(strategy, exp_choice, agent_choice)
  return(x)
}

adjacent_agent <- function(exp_choice){
  b <- runif(1, 0, 1)
  if (b > epsilon){
    agent_choice <- adjacent(exp_choice)
    strategy <- "adjacent"
  } else {
    agent_choice <- random(exp_choice)
    strategy <- "random"
  }  
  # print(paste0("Agent used the ", strategy, " strategy and picked ", agent_choice))
  x <- c(strategy, exp_choice, agent_choice)
  return(x)
}

# list of all agents -- will be used later to randomly call from all possible agents
agents <- list(random_agent, extreme_agent, diverse_agent, average_agent, middle_agent, adjacent_agent)
```

## Defining the hypothesis space 

This creates a matrix for each strategy, as well as a compiled matrix that has all possible selections given experimenter choice. This will be used to compare the agent's choices to. 
```{r}
random_matrix = as.data.frame(matrix(c(c(1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5),
                                       c(2,3,4,5,1,3,4,5,1,2,4,5,1,2,3,5,1,2,3,4),
                                       c(.25,.25,.25,.25,.25,.25,.25,.25,.25,.25,.25,.25,.25,.25,.25,.25,.25,.25,.25,.25),
                                       c(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)), 
                              ncol = 4))
random_matrix$prob_strategy <- "random"

extreme_matrix = as.data.frame(matrix(c(c(1,2,3,4,5),
                                        c(5,5,5,5,4),
                                        c(1,1,1,1,1),
                                        c(3,3,3,3,3)), 
                              ncol = 4))
extreme_matrix$prob_strategy <- "extreme"

diverse_matrix = as.data.frame(matrix(c(c(1,2,3,3,4,5),
                                        c(5,5,1,5,1,1),
                                        c(1,1,.5,.5,1,1),
                                        c(3,3,2,2,3,3)), 
                              ncol = 4))
diverse_matrix$prob_strategy <- "diverse"

average_matrix = as.data.frame(matrix(c(c(1,2,3,3,4,5),
                                        c(5,4,2,4,2,1),
                                        c(1,1,.5,.5,1,1),
                                        c(3,3,2,2,3,3)), 
                              ncol = 4))
average_matrix$prob_strategy <- "average"

middle_matrix = as.data.frame(matrix(c(c(1,2,3,3,4,5),
                                       c(3,3,4,2,3,3),
                                       c(1,1,.5,.5,1,1),
                                       c(3,3,2,2,3,3)), 
                              ncol = 4))
middle_matrix$prob_strategy <- "middle"

adjacent_matrix = as.data.frame(matrix(c(c(1,2,2,3,3,4,4,5),
                                         c(2,1,3,2,4,3,5,4),
                                         c(1,.5,.5,.5,.5,.5,.5,1),
                                         c(3,2,2,2,2,2,2,3)), 
                              ncol = 4))
adjacent_matrix$prob_strategy <- "adjacent"

# Listing all data frames and changing their names
dfs <- c("diverse_matrix", "extreme_matrix", "random_matrix", "average_matrix", "middle_matrix", "adjacent_matrix")

for(df in dfs) {
  df_tmp <- get(df)
  colnames(df_tmp) <- c("exp_choice","agent_choice", "probability","number_of_unexpected_choices","prob_strategy")
  assign(df, df_tmp)
}

df_list <- list(diverse_matrix, extreme_matrix, random_matrix, average_matrix, middle_matrix, adjacent_matrix)
```

## Defining the experimenter

This section defines how the experimenter goes about selecting their choice. 
```{r}
experimenter <- function(behavior){
  if (behavior == "random"){
    return(sample(experimenter_options,1))
  } else if (behavior == "ordered"){
    return(experimenter_options[i])
  }
}

```

## Setting epsilon and adjusting probability values in accordance with epsilon

```{r}
# Parameter to determine how often agent behaves randomly
# Lower values mean agent behaves less randomly
epsilon <- .1

# updating hypothesis space based on epsilon value
# will be needed for computing likelihoods later
expected_matrix <- bind_rows(df_list)
expected_matrix$prob_strategy <- as.factor(expected_matrix$prob_strategy)
expected_matrix$probability <- ifelse(expected_matrix$probability == .25, expected_matrix$probability, 
                                      expected_matrix$probability - (epsilon/(4-expected_matrix$number_of_unexpected_choices))) 
expected_matrix$probability_of_unexpected <- ifelse(expected_matrix$number_of_unexpected_choices == 0, 0,
                                                    epsilon/expected_matrix$number_of_unexpected_choices)
```

## Running the task 
```{r}
# initializing list of past agent actions
list_of_agent_histories = list()

# initializing values for for loops
number_of_agents <- 3 # this specifies the number of sets of 5 trials that are run e.g., if set to 4, 20 trials will be ran
i <- 0
iteration <- 0

# This runs the study -- here's where both the experimenter and agents make their choices across specified number of trials
for (iteration in 1:number_of_agents){
  agent_history <- as.data.frame(matrix(ncol = 4, nrow = 0)) # initializing past agent actions
  experimenter_options <- sample(1:5,5) # sets options for experimenter to choose from
  agent_strategy <- sample(1:6,1) # keeps agent type consistent for a set of five loops; after 5, resets
  for (i in 1:5){
    # parameter setting exp_choice
    exp_choice <- experimenter("ordered") # set to random for random selection, set to ordered to go through 1-5 options
    y <- agents[[agent_strategy]](exp_choice) # stores agent's choice based on exp's choice
    y <- as.data.frame(t(y)) # y is temp variable: transposes data to correct format and stores as df
    y[,4] <- iteration # saves agent's id
    agent_history <- rbind(agent_history, y) # add selection to agent history
    i <- i + 1
  }
  # Cleaning up the file
  # renaming columns
  x <- c("strategy", "exp_choice", "agent_choice","agent_id")
  colnames(agent_history) <- x
  agent_history <- agent_history[,c(4,2,3,1)] # reordering columns

  # making sure agent and experimenter choices are set to be numeric values
  agent_history$agent_choice <- as.numeric(as.character(agent_history$agent_choice))
  agent_history$exp_choice <- as.numeric(as.character(agent_history$exp_choice))

  list_of_agent_histories[[iteration]] <- agent_history
  iteration <- iteration + 1
  i <- 0
}
  
```

## Getting probabilities of data given strategy for each trial
```{r}

fill_in_probs <- function(df1, df2){
  a <- c("number_of_unexpected_choices", "probability_of_unexpected")
  # subsetting to have df with all strategies but random and then removing columns that will be added later
  temp1 <- subset(df1, prob_strategy != "random")
  temp1 <- temp1[,!(names(df1) %in% a)]
  # getting the columns removed from above from the main df that has all of them, so they can be merged back in
  temp2 <- subset(df2, prob_strategy != "random")
  temp2 <- temp2[, c(1,4:6)]
  # adding the columns back in so they are complete (no NA values)
  final <- unique(merge(temp1, temp2, by = c("exp_choice", "prob_strategy")))
  # now adding the random back in as well; had to treat random separately because they are unique strategy in terms
  # of number of possibilities
  temp3 <- subset(df1, prob_strategy == "random")
  final <- bind_rows(temp3, final)
  # filling in NAs for agent id and probabilities so template will be complete for computing likelihoods
  final$probability <- ifelse(is.na(final$probability), final$probability_of_unexpected, final$probability)
  final$agent_id <- ifelse(is.na(final$agent_id), i, final$agent_id)
  
  return(final)
}

# template that is used to save probabilities of data (agent's selection) given a specific strategy 
probability_template <- expand.grid(prob_strategy = unique(expected_matrix$prob_strategy),
                                    exp_choice = unique(expected_matrix$exp_choice))

list_of_probabilities = list()

# computing probabilities of data (agent's selection) given a specific strategy 
# Separate data frame for each agent
# Saving all to a list 
for(i in 1:length(list_of_agent_histories)){
  z <- inner_join(expected_matrix, list_of_agent_histories[[i]])
  z <- merge(probability_template, z, all = TRUE)
  list_of_probabilities[[i]] <- fill_in_probs(z, expected_matrix)
}

```
## Computing likelihoods of all observed data given each strategy
```{r}

probabilities <- plyr::rbind.fill(list_of_probabilities)

# list to store likelihood dfs
list_of_likelihoods <- list()

# function to compute likelihood of each strategy by individual
# TODO currently LL is not being calculated by agentid and strategy. Currently all group id's contributing to per strategy calc??
calculate_ll <- function(df, strategy){
  a <- strategy
  b <- df %>% group_by(agent_id) %>% filter(prob_strategy == a) %>% summarize(likelihood = prod(probability), 
                                                                                strategy_ll = a)
  return(b)
}

i <- 0
for(iteration in 1:(as.numeric(nrow(probabilities))/30)){
  # initializing likelihood df template
  likelihoods <- as.data.frame(matrix(ncol = 3, nrow = 0))
    for(i in 1:length(strategies)){
      # initializing likelihood df template
      y <- print(calculate_ll(probabilities, strategies[i]))
      likelihoods <- rbind(likelihoods, y)
      i <- i + 1
    }
  likelihoods$likelihoodXprior <- likelihoods$likelihood / length(strategies)
  likelihoods$agent_id <- iteration
  list_of_likelihoods[[iteration]] <- likelihoods
  i <- 0 
  iteration <- iteration + 1
}

likelihoods <- plyr::rbind.fill(list_of_likelihoods)


sum_ll <- likelihoods %>% group_by(agent_id) %>% dplyr::summarise(sum_ll = sum(likelihoodXprior))
                                            

print(likelihoods$likelihoodXprior[5]/sum_ll)



z %>% filter(prob_strategy == strategies[2]) %>% summarize(ll = prod(probability))
likelihood(final2, "extreme")

prod(z$probability)
extreme_prob <- z %>% filter(prob_strategy == "extreme") 
extreme_prob$probability <- as.numeric(extreme_prob$probability) - epsilon
likelihood_extreme <- prod(extreme_prob$probability)
likelihood_extreme*prior


test <- merge(z, random_matrix, by = c("exp_choice", "agent_choice"))
anti_join(agent_history, extreme_matrix)
anti_join(agent_history, diverse_matrix)

```


```{r}

agent_history$agent_choice <- as.numeric(as.character(agent_history$agent_choice))
agent_history$exp_choice <- as.numeric(as.character(agent_history$exp_choice))

ggplot(agent_history, aes(x = agent_choice, fill = strategy)) + 
  # geom_point(position = position_jitter(w = 0.1, h = 0.1),
  #            shape = 1,
  #            size = 2) + 
  geom_bar() +
  coord_cartesian(ylim=c(0,100)) +
  theme_classic()

```

Computing the posteriors
```{r}
# number of strategies 
n_strategy <- 6

# prior for each strategy
# currently, priors for each strategy assumed to be equal
prior <- 1/n_strategy

# computing the likelihoods


```

